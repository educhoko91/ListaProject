/*
 * generated by Xtext
 */
package edu.upb.lp.validation

import Lista.CompositeExpr
import Lista.Expression
import Lista.FunctionDefinition
import Lista.Identifier
import Lista.ListaPackage
import Lista.Operator
import Lista.Program
import edu.upb.lp.type.TypeIdentifier
import java.util.HashMap
import java.util.HashSet
import org.eclipse.xtext.validation.Check
import Lista.NumberExpression
import Lista.StringExpression
import Lista.BooleanExpression
import org.eclipse.emf.ecore.EObject
import Lista.Evaluation
import Lista.IfExpression
import Lista.SeqExpression
import Lista.OutputExpression
import Lista.NegExpr
import Lista.InputExpression

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class ListaValidator extends AbstractListaValidator {

	public HashMap<String, HashMap<String, String>> map;

	def initMap(Program prog) {
		this.map = TypeIdentifier.getInstance(prog).hashMap;
	}
	
	@Check
	def checkIdentifiersTypes(Identifier id) {
		var prog = id as EObject;
		while(!(prog instanceof Program)) {
			prog = prog.eContainer;
		}
		initMap(prog as Program);
		var eaux = id as EObject;
		while(!(eaux instanceof FunctionDefinition)) {
			eaux = eaux.eContainer;
		}
		var fd = eaux as FunctionDefinition
		if(map.get(fd.name).get(id.name)==TypeIdentifier.NOTYPE) {
			error("No se pudo determinar el tipo de "+id.name,
				ListaPackage.Literals.IDENTIFIER__NAME
			)
		}
	}

	@Check
	def checkFunctionDefinitionParams(Program prog) {
		initMap(prog);
		val setParams = new HashSet<String>;
		for (FunctionDefinition f : prog.functionDefinitions) {
			for (Identifier id : f.parameters) {
				if (!map.get(f.name).containsKey(id.name)) {
					error("El parametro \"" + id.name + "\" no esta siendo utilizado.",
						ListaPackage.Literals.PROGRAM__FUNCTION_DEFINITIONS);
				}
				setParams.add(id.name);
			}

			map.get(f.name).keySet.removeAll(setParams);
			for (String s : map.get(f.name).keySet) {
				error("El parametro " + s + " no esta declarado en la funcion.",
					ListaPackage.Literals.PROGRAM__FUNCTION_DEFINITIONS);
			}
		}
	}

	@Check
	def checkCompisiteOperatorValues(CompositeExpr expr) {
		var prog = expr as EObject
		while(!(prog instanceof Program))
			prog = prog.eContainer;
		initMap(prog as Program);
		recursiveCompisiteOperatorValuesCheck(expr,TypeIdentifier.NOTYPE);
		
	}
	
	@Check
	def checkIdentifiersInEvaluation(Evaluation eva) {
		recursiveIdentifiersInEvaluation(eva.expression);
		
	}
	
	def recursiveIdentifiersInEvaluation(Expression expr) {
		if(expr instanceof Identifier) {
			var id = expr  as Identifier
			error("No se pudo resolver el valor de " + id.name,
				ListaPackage.Literals.EVALUATION__EXPRESSION
			);
		}else if(expr instanceof NumberExpression) {
			return null;
		}else if(expr instanceof StringExpression) {
			return null;
		}else if(expr instanceof BooleanExpression) {
			return null;
		}
		else {
			if(expr instanceof CompositeExpr) {
				var ce = expr as CompositeExpr;
				try  {
					var left = ce.subExpressions.get(0);
					recursiveIdentifiersInEvaluation(left);
					var right = ce .subExpressions.get(1);
					recursiveIdentifiersInEvaluation(right);
				} catch (Exception e) {
				}
			}
			if(expr instanceof IfExpression) {
				var ifexpr = expr as IfExpression;
				recursiveIdentifiersInEvaluation(ifexpr.cond);
				recursiveIdentifiersInEvaluation(ifexpr.alternative);
				recursiveIdentifiersInEvaluation(ifexpr.consequent);
			}
			if(expr instanceof SeqExpression) {
				var secExp = expr as SeqExpression;
				for(Expression e : secExp.subExpressions) {
					recursiveIdentifiersInEvaluation(expr);
				}
			}
			if(expr instanceof OutputExpression) {
				var out = expr as OutputExpression
				recursiveIdentifiersInEvaluation(out.parameter);
			}
			if(expr instanceof NegExpr) {
				var ne = expr as NegExpr;
				recursiveIdentifiersInEvaluation(ne.subExpr);
			}
		}
		
	}
	
	def recursiveCompisiteOperatorValuesCheck(Expression expr, String type) {
		if (expr instanceof CompositeExpr) {
			val ce = expr as CompositeExpr;
			val o = ce.operator;
	
			if (o == Operator.PLUS || o == Operator.MINUS || o == Operator.DIVIDE || o == Operator.TIMES ||
				o == Operator.SMALLERTHAN) {
					try {
						val left = ce.subExpressions.get(0);
						val right = ce.subExpressions.get(1);
						val exprl = recursiveCompisiteOperatorValuesCheck(left,TypeIdentifier.TYPEINT);
						val exprr = recursiveCompisiteOperatorValuesCheck(right,TypeIdentifier.TYPEINT);
						if(!exprl.equals(TypeIdentifier.TYPEINT) || !exprr.equals(TypeIdentifier.TYPEINT)) {
							error("No se puede utilizar el operador "+o.name+" con "+exprl+", "+exprr+".", ListaPackage.Literals.COMPOSITE_EXPR__OPERATOR);
							return TypeIdentifier.NOTYPE;
						}else {
							return TypeIdentifier.TYPEINT;
						}
					
					} catch (Exception e) {}
					
			}
			
			if(o==Operator.CONCAT) {
				try {
						val left = ce.subExpressions.get(0);
						val right = ce.subExpressions.get(1);
						val exprl = recursiveCompisiteOperatorValuesCheck(left,TypeIdentifier.TYPESTRING);
						val exprr = recursiveCompisiteOperatorValuesCheck(right,TypeIdentifier.TYPESTRING);
						if(!exprl.equals(TypeIdentifier.TYPESTRING) || !exprr.equals(TypeIdentifier.TYPESTRING)) {
							error("No se puede utilizar el operador "+o.name+" con "+exprl+", "+exprr+".", ListaPackage.Literals.COMPOSITE_EXPR__OPERATOR);
							return TypeIdentifier.NOTYPE;
						}else {
							return TypeIdentifier.TYPESTRING;
						}
					
					} catch (Exception e) {}
			}
			
			if(o == Operator.AND || o == Operator.OR) {
				try {
						val left = ce.subExpressions.get(0);
						val right = ce.subExpressions.get(1);
						val exprl = recursiveCompisiteOperatorValuesCheck(left,TypeIdentifier.TYPEBOOLEAN);
						val exprr = recursiveCompisiteOperatorValuesCheck(right,TypeIdentifier.TYPEBOOLEAN);
						if(!exprl.equals(TypeIdentifier.TYPEBOOLEAN) || !exprr.equals(TypeIdentifier.TYPEBOOLEAN)) {
							error("No se puede utilizar el operador "+o.name+" con "+exprl+", "+exprr+".", ListaPackage.Literals.COMPOSITE_EXPR__OPERATOR);
							return TypeIdentifier.NOTYPE;
						}else {
							return TypeIdentifier.TYPEBOOLEAN;
						}
					
					} catch (Exception e) {}
			}
		}
		if(expr instanceof NumberExpression) {
			return TypeIdentifier.TYPEINT;
		}
		
		if(expr instanceof StringExpression) {
			return TypeIdentifier.TYPESTRING;
		}
		
		if(expr  instanceof BooleanExpression) {
			return TypeIdentifier.TYPEBOOLEAN;
		}
		
		if(expr instanceof Identifier) {
			var id = expr as Identifier;
			var eaux = expr as EObject;
			while(!(eaux instanceof FunctionDefinition)) {
				eaux = eaux.eContainer;
			}
			if (map.get((eaux as FunctionDefinition).name).get(id.name)==TypeIdentifier.NOTYPE) {
				return type;
			} else {
				return map.get((eaux as FunctionDefinition).name).get(id.name);
			}
		}
		
		if(expr  instanceof SeqExpression) {
			var seq = expr as SeqExpression;
			return recursiveCompisiteOperatorValuesCheck(seq.subExpressions.last, type);
			
		}
		
		if(expr instanceof IfExpression) {
			var ife = expr as IfExpression
			return recursiveCompisiteOperatorValuesCheck(ife.consequent, type);
		}
		
		if (expr instanceof OutputExpression) {
			var oexp = expr as OutputExpression;
			return recursiveCompisiteOperatorValuesCheck(oexp.parameter, type);
		}
		
		if(expr instanceof InputExpression) {
			return type;
		}
		
		return TypeIdentifier.NOTYPE;
	}
}


