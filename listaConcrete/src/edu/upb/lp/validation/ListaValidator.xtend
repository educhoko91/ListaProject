/*
 * generated by Xtext
 */
package edu.upb.lp.validation

import Lista.CompositeExpr
import Lista.Expression
import Lista.FunctionDefinition
import Lista.Identifier
import Lista.ListaPackage
import Lista.Operator
import Lista.Program
import edu.upb.lp.type.TypeIdentifier
import java.util.HashMap
import java.util.HashSet
import org.eclipse.xtext.validation.Check
import java.awt.Composite
import org.eclipse.emf.codegen.ecore.genmodel.impl.Literals
import Lista.NumberExpression
import Lista.StringExpression
import Lista.BooleanExpression
import org.eclipse.emf.ecore.EObject

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class ListaValidator extends AbstractListaValidator {

	//  public static val INVALID_NAME = 'invalidName'
	//
	//	@Check
	//	def checkGreetingStartsWithCapital(Greeting greeting) {
	//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
	//			warning('Name should start with a capital', 
	//					MyDslPackage.Literals.GREETING__NAME,
	//					INVALID_NAME)
	//		}
	//	}
	public HashMap<String, HashMap<String, String>> map;

	def initMap(Program prog) {
		this.map = TypeIdentifier.getInstance(prog).hashMap;
	}

	@Check
	def checkFunctionDefinitionParams(Program prog) {
		initMap(prog);
		val setParams = new HashSet<String>;
		for (FunctionDefinition f : prog.functionDefinitions) {
			for (Identifier id : f.parameters) {
				if (!map.get(f.name).containsKey(id.name)) {
					error("El parametro \"" + id.name + "\" no esta siendo utilizado.",
						ListaPackage.Literals.PROGRAM__FUNCTION_DEFINITIONS);
				}
				setParams.add(id.name);
			}

			map.get(f.name).keySet.removeAll(setParams);
			for (String s : map.get(f.name).keySet) {
				error("El parametro \"" + s + "\" no esta declarado en la funcion.",
					ListaPackage.Literals.PROGRAM__FUNCTION_DEFINITIONS);
			}
		}
	}

	@Check
	def checkCompisiteOperatorValues(CompositeExpr expr) {
		var prog = expr as EObject
		while(!(prog instanceof Program))
			prog = prog.eContainer;
		initMap(prog as Program);
		recursiveCompisiteOperatorValuesCheck(expr);
		
	}
	
	def recursiveCompisiteOperatorValuesCheck(Expression expr) {
		if (expr instanceof CompositeExpr) {
			val ce = expr as CompositeExpr;
			val left = ce.subExpressions.get(0);
			val right = ce.subExpressions.get(1);
			val o = ce.operator;
	
			if (o == Operator.PLUS || o == Operator.MINUS || o == Operator.DIVIDE || o == Operator.TIMES ||
				o == Operator.SMALLERTHAN) {
					val exprl = recursiveCompisiteOperatorValuesCheck(left);
					val exprr = recursiveCompisiteOperatorValuesCheck(right);
					if(!exprl.equals(TypeIdentifier.TYPEINT) || !exprr.equals(TypeIdentifier.TYPEINT)) {
						error("No se puede se puede utilizar el operador "+o.name+" con "+exprl+", "+exprr+".", ListaPackage.Literals.COMPOSITE_EXPR__OPERATOR);
						return null;
					}else {
						return TypeIdentifier.TYPEINT;
					}
					
			}
		}
		if(expr instanceof NumberExpression) {
			return TypeIdentifier.TYPEINT;
		}
		
		if(expr instanceof StringExpression) {
			return TypeIdentifier.TYPESTRING;
		}
		
		if(expr  instanceof BooleanExpression) {
			return TypeIdentifier.TYPEBOOLEAN;
		}
		
		return null;
	}
}


