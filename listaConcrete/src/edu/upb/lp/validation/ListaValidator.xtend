/*
 * generated by Xtext
 */
package edu.upb.lp.validation

import Lista.CompositeExpr
import Lista.Expression
import Lista.FunctionDefinition
import Lista.Identifier
import Lista.ListaPackage
import Lista.Operator
import Lista.Program
import edu.upb.lp.type.TypeIdentifier
import java.util.HashMap
import java.util.HashSet
import org.eclipse.xtext.validation.Check
import Lista.NumberExpression
import Lista.StringExpression
import Lista.BooleanExpression
import org.eclipse.emf.ecore.EObject
import Lista.Evaluation
import Lista.IfExpression
import Lista.SeqExpression
import Lista.OutputExpression
import Lista.NegExpr
import Lista.InputExpression
import com.google.common.base.Function
import Lista.FunctionCall
import org.eclipse.emf.codegen.ecore.genmodel.impl.Literals

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class ListaValidator extends AbstractListaValidator {
	
	public static final String INPUTTYPE="input";

	public HashMap<String, HashMap<String, String>> map;

	def initMap(Program prog) {
		this.map = TypeIdentifier.getInstance(prog).hashMap;
		System.out.println(map);
	}
	
	@Check
	def checkIdentifiersTypes(Identifier id) {
		var prog = id as EObject;
		while(!(prog instanceof Program)) {
			prog = prog.eContainer;
		}
		initMap(prog as Program);
		var eaux = id as EObject;
		while(!(eaux instanceof FunctionDefinition)) {
			eaux = eaux.eContainer;
		}
		var fd = eaux as FunctionDefinition
		if(map.get(fd.name).get(id.name)==TypeIdentifier.NOTYPE ||
			map.get(fd.name).get(id.name)==null) {
			error("No se pudo determinar el tipo de "+id.name,
				ListaPackage.Literals.IDENTIFIER__NAME
			)
		}
	}

	@Check
	def checkFunctionDefinitionParams(FunctionDefinition f) {
		var prog = f as EObject;
		while(!(prog instanceof Program)) {
			prog = prog.eContainer;
		}
		initMap(prog as Program);
		val setParams = new HashSet<String>;
		for (Identifier id : f.parameters) {
			if (!map.get(f.name).containsKey(id.name)) {
				error("El parametro \"" + id.name + "\" no esta siendo utilizado.",
					ListaPackage.Literals.FUNCTION_DEFINITION__PARAMETERS);
			}
			setParams.add(id.name);
		}

		map.get(f.name).keySet.removeAll(setParams);
		for (String s : map.get(f.name).keySet) {
			error("El parametro " + s + " no esta declarado en la funcion.",
				ListaPackage.Literals.FUNCTION_DEFINITION__PARAMETERS);
		}
	}

	@Check
	def checkCompisiteOperatorValues(CompositeExpr expr) {
		var prog = expr as EObject
		while(!(prog instanceof Program))
			prog = prog.eContainer;
		initMap(prog as Program);
		recursiveCompisiteOperatorValuesCheck(expr,TypeIdentifier.NOTYPE);
		
	}
	
	@Check
	def checkIdentifiersInEvaluation(Evaluation eva) {
		recursiveIdentifiersInEvaluation(eva.expression);
		
	}
	
	@Check
	def checkArgumentsOnFunctionCall(FunctionCall fc) {
		var prog = fc as EObject
		while(!(prog instanceof Program))
			prog = prog.eContainer;
		initMap(prog as Program);
		
		if(fc.arguments.size==fc.function.parameters.size) {
		
			var cnd = 0;
			var f = fc.function.name;
			for(Expression e: fc.arguments) {
				var p = fc.function.parameters.get(cnd).name;
				var a = recursiveArgumentOnFunctionCall(e) as String;
				var b = map.get(f).get(p);
				functionCallTypeCheck(a,b,f,p);
				cnd = 1+cnd;
			}
			
		}
		else {
			error("Faltan Parametos!!!", ListaPackage.Literals.FUNCTION_CALL__FUNCTION);
		}
	}
	
	@Check
	def checkIfExprReturnType(IfExpression iexpr) {
		var cond = recursiveIfExprReturnType(iexpr.cond);
		var consequent = recursiveIfExprReturnType(iexpr.consequent);
		var alternative = recursiveIfExprReturnType(iexpr.alternative);
		
		if(!cond.equals(INPUTTYPE)) {
			if (cond.equals(TypeIdentifier.TYPEBOOLEAN)) {
				if(!consequent.equals(INPUTTYPE) && !alternative.equals(INPUTTYPE)) {
					if(!consequent.equals(alternative)) {
						error("Los valores de retorno deben ser iguales",
							ListaPackage.Literals.IF_EXPRESSION__ALTERNATIVE
						)
					}
				
				}
			}
			else {
				error("La consecuencia debe ser Boolean",
						ListaPackage.Literals.IF_EXPRESSION__COND
					)
			}
		}
		else {
			if(!consequent.equals(INPUTTYPE) && !alternative.equals(INPUTTYPE)) {
					if(!consequent.equals(alternative)) {
						error("Los valores de retorno deben ser iguales",
							ListaPackage.Literals.IF_EXPRESSION__ALTERNATIVE
						)
					}
				}
		}
		
	}
	
	def recursiveIfExprReturnType(Expression expr) {
		if(expr instanceof NumberExpression) {
			return TypeIdentifier.TYPEINT;
		}
		if(expr instanceof StringExpression) {
			return TypeIdentifier.TYPESTRING;
		}
		if(expr instanceof BooleanExpression) {
			return TypeIdentifier.TYPEBOOLEAN;
		}
		
		if (expr instanceof CompositeExpr) {
			val ce = expr as CompositeExpr;
			val o = ce.operator;
	
			if (o == Operator.PLUS || o == Operator.MINUS || o == Operator.DIVIDE || o == Operator.TIMES ||
				o == Operator.SMALLERTHAN) {
					return TypeIdentifier.TYPEINT;
					
			}
			
			if(o==Operator.CONCAT) {
				return TypeIdentifier.TYPESTRING;
			}
			
			if(o == Operator.AND || o == Operator.OR) {
				return TypeIdentifier.TYPEBOOLEAN
			}
		}
		
		if(expr instanceof SeqExpression) {
			var se = expr as SeqExpression;
			return recursiveIfExprReturnType(se.subExpressions.last);
		}
		
		if (expr instanceof IfExpression) {
			var ie = expr as IfExpression;
			var a = recursiveIfExprReturnType(ie.consequent);
			var b = recursiveIfExprReturnType(ie.alternative);
			if(a.equals(b))
				return a;
			return TypeIdentifier.NOTYPE;
		}
		
		if(expr instanceof OutputExpression) {
			var oe = expr as OutputExpression;
			return recursiveIfExprReturnType(oe.parameter);
		}
		
		if(expr instanceof InputExpression) {
			return INPUTTYPE;
		}
		
		if(expr instanceof FunctionCall) {
			var fc= expr as FunctionCall;
			return map.get("global").get(fc.function.name);
		}
		 
		 return TypeIdentifier.NOTYPE;
		
	}
	
	def recursiveArgumentOnFunctionCall(Expression expr) {
		if(expr instanceof NumberExpression) {
			return TypeIdentifier.TYPEINT;
		}
		if(expr instanceof StringExpression) {
			return TypeIdentifier.TYPESTRING;
		}
		if(expr instanceof BooleanExpression) {
			return TypeIdentifier.TYPEBOOLEAN;
		}
		
		if (expr instanceof CompositeExpr) {
			val ce = expr as CompositeExpr;
			val o = ce.operator;
	
			if (o == Operator.PLUS || o == Operator.MINUS || o == Operator.DIVIDE || o == Operator.TIMES ||
				o == Operator.SMALLERTHAN) {
					return TypeIdentifier.TYPEINT;
					
			}
			
			if(o==Operator.CONCAT) {
				return TypeIdentifier.TYPESTRING;
			}
			
			if(o == Operator.AND || o == Operator.OR) {
				return TypeIdentifier.TYPEBOOLEAN
			}
		}
		
		if(expr instanceof SeqExpression) {
			var se = expr as SeqExpression;
			return recursiveArgumentOnFunctionCall(se.subExpressions.last);
		}
		
		if (expr instanceof IfExpression) {
			var ie = expr as IfExpression;
			var a = recursiveArgumentOnFunctionCall(ie.consequent);
			var b = recursiveArgumentOnFunctionCall(ie.alternative);
			if(a.equals(b))
				return a;
			return TypeIdentifier.NOTYPE;
		}
		
		if(expr instanceof OutputExpression) {
			var oe = expr as OutputExpression;
			return recursiveArgumentOnFunctionCall(oe.parameter);
		}
		
		if(expr instanceof InputExpression) {
			return INPUTTYPE;
		}
		
		if(expr instanceof FunctionCall) {
			var fc= expr as FunctionCall;
			return map.get("global").get(fc.function.name);
		}
		 
		 return TypeIdentifier.NOTYPE;
		
	}
	
	def functionCallTypeCheck(String a, String b, String f, String p) {
		if(!a.equals(INPUTTYPE))
			if(!a.equals(b)) {
				error("La Funcion "+f+" en el parametro "+p+" resive un "+b+" y no un "+a,
					ListaPackage.Literals.FUNCTION_CALL__FUNCTION
				)
			}
	}
	
	def recursiveIdentifiersInEvaluation(Expression expr) {
		if(expr instanceof Identifier) {
			var id = expr  as Identifier
			error("No se pudo resolver el valor de " + id.name,
				ListaPackage.Literals.EVALUATION__EXPRESSION
			);
		}else if(expr instanceof NumberExpression) {
			return null;
		}else if(expr instanceof StringExpression) {
			return null;
		}else if(expr instanceof BooleanExpression) {
			return null;
		}
		else {
			if(expr instanceof CompositeExpr) {
				var ce = expr as CompositeExpr;
				try  {
					var left = ce.subExpressions.get(0);
					recursiveIdentifiersInEvaluation(left);
					var right = ce .subExpressions.get(1);
					recursiveIdentifiersInEvaluation(right);
				} catch (Exception e) {
				}
			}
			if(expr instanceof IfExpression) {
				var ifexpr = expr as IfExpression;
				recursiveIdentifiersInEvaluation(ifexpr.cond);
				recursiveIdentifiersInEvaluation(ifexpr.alternative);
				recursiveIdentifiersInEvaluation(ifexpr.consequent);
			}
			if(expr instanceof SeqExpression) {
				var secExp = expr as SeqExpression;
				for(Expression e : secExp.subExpressions) {
					recursiveIdentifiersInEvaluation(e);
				}
			}
			if(expr instanceof OutputExpression) {
				var out = expr as OutputExpression
				recursiveIdentifiersInEvaluation(out.parameter);
			}
			if(expr instanceof NegExpr) {
				var ne = expr as NegExpr;
				recursiveIdentifiersInEvaluation(ne.subExpr);
			}
			
			if(expr instanceof FunctionCall) {
				var fc = expr as FunctionCall;
				for (Expression e : fc.arguments) {
					recursiveIdentifiersInEvaluation(e);
				}
			}
			
		}
		
	}
	
	def recursiveCompisiteOperatorValuesCheck(Expression expr, String type) {
		if (expr instanceof CompositeExpr) {
			val ce = expr as CompositeExpr;
			val o = ce.operator;
	
			if (o == Operator.PLUS || o == Operator.MINUS || o == Operator.DIVIDE || o == Operator.TIMES ||
				o == Operator.SMALLERTHAN) {
					try {
						val left = ce.subExpressions.get(0);
						val right = ce.subExpressions.get(1);
						val exprl = recursiveCompisiteOperatorValuesCheck(left,TypeIdentifier.TYPEINT);
						val exprr = recursiveCompisiteOperatorValuesCheck(right,TypeIdentifier.TYPEINT);
						if(!exprl.equals(TypeIdentifier.TYPEINT) || !exprr.equals(TypeIdentifier.TYPEINT)) {
							error("No se puede utilizar el operador "+o.name+" con "+exprl+", "+exprr+".", ListaPackage.Literals.COMPOSITE_EXPR__OPERATOR);
							return TypeIdentifier.NOTYPE;
						}else {
							return TypeIdentifier.TYPEINT;
						}
					
					} catch (Exception e) {}
					
			}
			
			if(o==Operator.CONCAT) {
				try {
						val left = ce.subExpressions.get(0);
						val right = ce.subExpressions.get(1);
						val exprl = recursiveCompisiteOperatorValuesCheck(left,TypeIdentifier.TYPESTRING);
						val exprr = recursiveCompisiteOperatorValuesCheck(right,TypeIdentifier.TYPESTRING);
						if(!exprl.equals(TypeIdentifier.TYPESTRING) || !exprr.equals(TypeIdentifier.TYPESTRING)) {
							error("No se puede utilizar el operador "+o.name+" con "+exprl+", "+exprr+".", ListaPackage.Literals.COMPOSITE_EXPR__OPERATOR);
							return TypeIdentifier.NOTYPE;
						}else {
							return TypeIdentifier.TYPESTRING;
						}
					
					} catch (Exception e) {}
			}
			
			if(o == Operator.AND || o == Operator.OR) {
				try {
						val left = ce.subExpressions.get(0);
						val right = ce.subExpressions.get(1);
						val exprl = recursiveCompisiteOperatorValuesCheck(left,TypeIdentifier.TYPEBOOLEAN);
						val exprr = recursiveCompisiteOperatorValuesCheck(right,TypeIdentifier.TYPEBOOLEAN);
						if(!exprl.equals(TypeIdentifier.TYPEBOOLEAN) || !exprr.equals(TypeIdentifier.TYPEBOOLEAN)) {
							error("No se puede utilizar el operador "+o.name+" con "+exprl+", "+exprr+".", ListaPackage.Literals.COMPOSITE_EXPR__OPERATOR);
							return TypeIdentifier.NOTYPE;
						}else {
							return TypeIdentifier.TYPEBOOLEAN;
						}
					
					} catch (Exception e) {}
			}
		}
		if(expr instanceof NumberExpression) {
			return TypeIdentifier.TYPEINT;
		}
		
		if(expr instanceof StringExpression) {
			return TypeIdentifier.TYPESTRING;
		}
		
		if(expr  instanceof BooleanExpression) {
			return TypeIdentifier.TYPEBOOLEAN;
		}
		
		if(expr instanceof Identifier) {
			var id = expr as Identifier;
			var eaux = expr as EObject;
			while(!(eaux instanceof FunctionDefinition)) {
				eaux = eaux.eContainer;
			}
			if (map.get((eaux as FunctionDefinition).name).get(id.name)==TypeIdentifier.NOTYPE) {
				return type;
			} else {
				return map.get((eaux as FunctionDefinition).name).get(id.name);
			}
		}
		
		if(expr  instanceof SeqExpression) {
			var seq = expr as SeqExpression;
			return recursiveCompisiteOperatorValuesCheck(seq.subExpressions.last, type);
			
		}
		
		if(expr instanceof IfExpression) {
			var ife = expr as IfExpression
			return recursiveCompisiteOperatorValuesCheck(ife.consequent, type);
		}
		
		if (expr instanceof OutputExpression) {
			var oexp = expr as OutputExpression;
			return recursiveCompisiteOperatorValuesCheck(oexp.parameter, type);
		}
		
		if(expr instanceof InputExpression) {
			return type;
		}
		
		if(expr instanceof FunctionCall) {
			var fc = expr as FunctionCall;
			for(Expression e : fc.arguments) {
				recursiveCompisiteOperatorValuesCheck(e, type);
			}
			return map.get("global").get(fc.function.name);
		}
		
		return TypeIdentifier.NOTYPE;
	}
}


